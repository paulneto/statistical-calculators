<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Cluster Analysis Calculator</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-50">
    <div id="root"></div>
    <script type="text/babel">
        const { useState } = React;

        const defaultData = `CustomerID,Age,Income,PurchaseFreq,AvgOrder
1,24,32000,2,35
2,26,35000,3,40
3,23,30000,2,32
4,25,33000,2,38
5,27,34000,3,42
6,22,31000,1,30
7,24,32000,2,36
8,26,35000,3,41
9,23,33000,2,34
10,25,31000,2,37
11,38,58000,8,85
12,42,62000,9,90
13,40,60000,8,88
14,39,59000,9,87
15,41,61000,8,92
16,37,57000,7,83
17,43,63000,10,95
18,40,60000,9,89
19,38,58000,8,86
20,41,62000,9,91
21,47,88000,18,180
22,52,95000,20,195
23,49,90000,19,185
24,50,92000,18,188
25,48,89000,19,182
26,51,94000,20,192
27,46,87000,17,178
28,53,96000,21,198
29,49,91000,19,187
30,50,93000,20,190
31,55,82000,3,220
32,58,85000,2,240
33,56,83000,3,225
34,57,84000,2,235
35,59,86000,3,245
36,54,81000,2,215
37,60,87000,3,250
38,56,83000,2,230
39,57,85000,3,238
40,58,84000,2,228
41,25,34000,2,36
42,40,59000,8,87
43,48,90000,19,186
44,56,84000,3,232
45,26,32000,3,38
46,41,61000,9,90
47,50,92000,20,191
48,57,85000,2,237
49,24,31000,2,34
50,39,60000,8,88`;

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index];
                });
                data.push(row);
            }

            return { headers, data };
        }

        function euclideanDistance(point1, point2) {
            let sum = 0;
            for (let key in point1) {
                sum += Math.pow(point1[key] - point2[key], 2);
            }
            return Math.sqrt(sum);
        }

        function standardizeFeatures(data, features) {
            // Calculate mean and std dev for each feature
            const stats = {};
            features.forEach(feature => {
                const values = data.map(row => parseFloat(row[feature]));
                const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);
                stats[feature] = { mean, stdDev: stdDev || 1 }; // Avoid division by zero
            });

            // Standardize: (value - mean) / stdDev
            const standardized = data.map(row => {
                const standardizedRow = { ...row };
                features.forEach(feature => {
                    const value = parseFloat(row[feature]);
                    standardizedRow[feature] = (value - stats[feature].mean) / stats[feature].stdDev;
                });
                return standardizedRow;
            });

            return { standardized, stats };
        }

        function kMeans(data, k, features, maxIterations = 100) {
            // Standardize features first (critical for K-means!)
            const { standardized, stats } = standardizeFeatures(data, features);

            const points = standardized.map(row => {
                const point = {};
                features.forEach(feature => {
                    point[feature] = parseFloat(row[feature]);
                });
                return point;
            });

            // Random initialization
            let centroids = [];
            const usedIndices = new Set();
            while (centroids.length < k) {
                const randomIndex = Math.floor(Math.random() * points.length);
                if (!usedIndices.has(randomIndex)) {
                    centroids.push({ ...points[randomIndex] });
                    usedIndices.add(randomIndex);
                }
            }

            let assignments = new Array(points.length).fill(0);
            let iterations = 0;
            let converged = false;

            while (!converged && iterations < maxIterations) {
                // Assign points to nearest centroid
                const newAssignments = points.map(point => {
                    let minDistance = Infinity;
                    let clusterIndex = 0;

                    centroids.forEach((centroid, index) => {
                        const distance = euclideanDistance(point, centroid);
                        if (distance < minDistance) {
                            minDistance = distance;
                            clusterIndex = index;
                        }
                    });

                    return clusterIndex;
                });

                // Check convergence
                converged = newAssignments.every((val, idx) => val === assignments[idx]);
                assignments = newAssignments;

                // Update centroids
                centroids = centroids.map((_, clusterIndex) => {
                    const clusterPoints = points.filter((_, idx) => assignments[idx] === clusterIndex);

                    if (clusterPoints.length === 0) {
                        return centroids[clusterIndex];
                    }

                    const newCentroid = {};
                    features.forEach(feature => {
                        newCentroid[feature] = clusterPoints.reduce((sum, point) => sum + point[feature], 0) / clusterPoints.length;
                    });

                    return newCentroid;
                });

                iterations++;
            }

            // Calculate WCSS
            let wcss = 0;
            points.forEach((point, idx) => {
                const centroid = centroids[assignments[idx]];
                wcss += Math.pow(euclideanDistance(point, centroid), 2);
            });

            return { assignments, centroids, wcss, iterations };
        }

        function calculateElbowData(data, features, maxK = 10) {
            const elbowData = [];

            for (let k = 1; k <= maxK; k++) {
                const result = kMeans(data, k, features);
                elbowData.push({ k, wcss: result.wcss });
            }

            return elbowData;
        }

        function getClusterSummary(data, assignments, centroids, features) {
            const clusters = centroids.map((centroid, index) => {
                const clusterPoints = data.filter((_, idx) => assignments[idx] === index);
                const size = clusterPoints.length;

                const stats = {};
                features.forEach(feature => {
                    const values = clusterPoints.map(row => parseFloat(row[feature]));
                    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    stats[feature] = { mean, min, max };
                });

                return { id: index + 1, size, centroid, stats };
            });

            return clusters;
        }

        function interpretCluster(cluster, allClusters, features) {
            // Generate interpretation based on relative values across all clusters
            const featureDescriptions = [];

            features.forEach(feature => {
                const value = cluster.centroid[feature];
                const allValues = allClusters.map(c => c.centroid[feature]);
                const min = Math.min(...allValues);
                const max = Math.max(...allValues);
                const range = max - min;

                if (range === 0) return; // Skip if all values are the same

                const percentile = (value - min) / range;

                let level;
                if (percentile < 0.33) level = "Low";
                else if (percentile < 0.67) level = "Medium";
                else level = "High";

                featureDescriptions.push(`${level} ${feature}`);
            });

            return featureDescriptions.join(", ");
        }

        function ClusterAnalysisCalculator() {
            const [k, setK] = useState(4);
            const [csvData, setCsvData] = useState(defaultData);
            const [results, setResults] = useState(null);

            const calculate = () => {
                try {
                    const { headers, data } = parseCSV(csvData);
                    // Use all columns except the first one (ID column)
                    const features = headers.slice(1);

                    // Perform K-means clustering
                    const { assignments, centroids, wcss, iterations } = kMeans(data, k, features);

                    // Calculate cluster summaries
                    const clusterSummary = getClusterSummary(data, assignments, centroids, features);

                    // Calculate elbow data
                    const elbowData = calculateElbowData(data, features, 10);

                    // Add cluster assignments to data
                    const dataWithClusters = data.map((row, idx) => ({
                        ...row,
                        Cluster: assignments[idx] + 1
                    }));

                    setResults({
                        clusterSummary,
                        elbowData,
                        wcss,
                        iterations,
                        dataWithClusters,
                        features
                    });
                } catch (error) {
                    alert('Error: ' + error.message);
                }
            };

            return (
                <div className="min-h-screen bg-gray-50">
                    {/* Header */}
                    <div style={{background: 'linear-gradient(to right, #16a34a, #059669)'}} className="text-white shadow-lg">
                        <div className="max-w-7xl mx-auto px-4 py-6">
                            <div className="flex items-center justify-between mb-2">
                                <h1 className="text-2xl font-bold text-white">K-Means Cluster Analysis Calculator</h1>
                                <a href="../index.html" style={{backgroundColor: '#ffffff', color: '#16a34a'}} className="px-4 py-2 rounded-lg font-semibold hover:bg-gray-100 transition text-sm">
                                    ← Back to Calculators
                                </a>
                            </div>
                            <p className="text-white text-sm font-medium">Segment customers into distinct groups based on multiple characteristics</p>
                        </div>
                    </div>

                    <div className="max-w-6xl mx-auto px-4 py-8">

                        {/* Info Section */}
                        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
                            <h2 className="text-2xl font-bold mb-4 text-gray-800">What is Cluster Analysis?</h2>
                            <p className="text-gray-700 mb-4">
                                Cluster analysis groups similar data points together <strong>without predefined labels</strong>.
                                K-means is the most common clustering method — it finds k groups by minimizing distance within clusters.
                                All features are <strong>automatically standardized</strong> (z-score normalization) so each feature contributes equally.
                            </p>
                            <div className="bg-green-50 border-l-4 border-green-500 p-4 mb-4">
                                <h3 className="font-bold text-green-900 mb-2">Perfect for Customer Segmentation:</h3>
                                <ul className="list-disc list-inside text-gray-700 space-y-1">
                                    <li>Find natural customer groups in your data</li>
                                    <li>Understand what makes each segment unique</li>
                                    <li>Target different segments with tailored strategies</li>
                                    <li>Discover patterns you didn't know existed</li>
                                </ul>
                            </div>
                        </div>

                        {/* Settings */}
                        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
                            <h2 className="text-2xl font-bold mb-4 text-gray-800">Settings</h2>
                            <div className="space-y-6">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Number of Clusters (k)
                                    </label>
                                    <p className="text-sm text-gray-600 mb-2">
                                        How many customer segments do you want to find? Use the elbow plot below to help decide.
                                    </p>
                                    <input
                                        type="number"
                                        min="2"
                                        max="10"
                                        value={k}
                                        onChange={(e) => setK(parseInt(e.target.value))}
                                        className="w-32 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"
                                    />
                                </div>
                            </div>
                        </div>

                        {/* Data Input */}
                        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
                            <h2 className="text-2xl font-bold mb-4 text-gray-800">Enter Your Data</h2>
                            <p className="text-gray-600 mb-4">
                                <strong>Format:</strong> CSV with any column headers. The first column is treated as an ID and excluded from clustering.
                                All remaining numeric columns will be used as features for clustering. You can use any column names (Age, Income, Spend, etc.).
                            </p>
                            <p className="text-gray-600 mb-4 text-sm">
                                <strong>Example:</strong> CustomerID,Age,Income,PurchaseFreq,AvgOrder (or use your own column names)
                            </p>
                            <textarea
                                value={csvData}
                                onChange={(e) => setCsvData(e.target.value)}
                                rows="12"
                                className="w-full p-4 border border-gray-300 rounded-lg font-mono text-sm"
                                placeholder="ID,Feature1,Feature2,Feature3&#10;1,25,35000,2&#10;2,45,75000,12&#10;..."
                            />
                            <button
                                onClick={calculate}
                                className="mt-4 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg transition duration-200"
                            >
                                Perform Cluster Analysis
                            </button>
                        </div>

                        {results && (
                            <>
                                <div className="bg-white rounded-lg shadow-lg p-8 mb-8">
                                    <h2 className="text-2xl font-bold text-green-600 mb-4">Clustering Results</h2>
                                    <div className="grid grid-cols-2 gap-4 mb-6">
                                        <div className="bg-green-50 p-4 rounded-lg">
                                            <p className="text-sm text-gray-600">Within-Cluster Sum of Squares</p>
                                            <p className="text-2xl font-bold text-green-600">{results.wcss.toFixed(2)}</p>
                                            <p className="text-xs text-gray-500 mt-1">Based on standardized features</p>
                                        </div>
                                        <div className="bg-green-50 p-4 rounded-lg">
                                            <p className="text-sm text-gray-600">Iterations to Convergence</p>
                                            <p className="text-2xl font-bold text-green-600">{results.iterations}</p>
                                        </div>
                                    </div>
                                </div>

                                <div className="bg-white rounded-lg shadow-lg p-8 mb-8">
                                    <h2 className="text-2xl font-bold text-green-600 mb-4">Cluster Summaries</h2>
                                    <div className="space-y-6">
                                        {results.clusterSummary.map((cluster) => (
                                            <div key={cluster.id} className="border border-green-200 rounded-lg p-6">
                                                <div className="flex justify-between items-start mb-4">
                                                    <h3 className="text-xl font-bold text-green-600">Cluster {cluster.id}</h3>
                                                    <span className="bg-green-100 text-green-700 px-3 py-1 rounded-full text-sm font-semibold">
                                                        {cluster.size} customers
                                                    </span>
                                                </div>

                                                <div className="bg-green-50 p-4 rounded-lg mb-4">
                                                    <p className="text-sm font-medium text-gray-700 mb-1">Interpretation:</p>
                                                    <p className="text-gray-800 italic">{interpretCluster(cluster, results.clusterSummary, results.features)}</p>
                                                </div>

                                                <div className="grid grid-cols-2 gap-4">
                                                    {results.features.map((feature) => (
                                                        <div key={feature} className="bg-gray-50 p-3 rounded">
                                                            <p className="text-sm font-medium text-gray-700">{feature}</p>
                                                            <p className="text-lg font-bold text-green-600">
                                                                {cluster.stats[feature].mean.toFixed(2)}
                                                            </p>
                                                            <p className="text-xs text-gray-500">
                                                                Range: {cluster.stats[feature].min.toFixed(1)} - {cluster.stats[feature].max.toFixed(1)}
                                                            </p>
                                                        </div>
                                                    ))}
                                                </div>

                                                <div className="mt-4 pt-4 border-t border-green-100">
                                                    <p className="text-sm font-medium text-gray-700 mb-2">Centroid Coordinates:</p>
                                                    <p className="text-sm text-gray-600 font-mono">
                                                        {results.features.map(f => `${f}: ${cluster.centroid[f].toFixed(2)}`).join(', ')}
                                                    </p>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                <div className="bg-white rounded-lg shadow-lg p-8 mb-8">
                                    <h2 className="text-2xl font-bold text-green-600 mb-4">Elbow Plot</h2>
                                    <p className="text-gray-600 mb-4">Within-Cluster Sum of Squares (WCSS) for different values of k</p>

                                    {/* SVG Line Chart */}
                                    <div className="bg-gray-50 p-6 rounded-lg mb-4">
                                        <svg width="100%" height="300" viewBox="0 0 600 300" className="max-w-full">
                                            {/* Grid lines */}
                                            {[0, 1, 2, 3, 4].map(i => (
                                                <line
                                                    key={`grid-${i}`}
                                                    x1="60"
                                                    y1={50 + i * 50}
                                                    x2="580"
                                                    y2={50 + i * 50}
                                                    stroke="#e5e7eb"
                                                    strokeWidth="1"
                                                />
                                            ))}

                                            {/* Axes */}
                                            <line x1="60" y1="250" x2="580" y2="250" stroke="#374151" strokeWidth="2" />
                                            <line x1="60" y1="50" x2="60" y2="250" stroke="#374151" strokeWidth="2" />

                                            {/* Y-axis label */}
                                            <text x="20" y="150" fill="#374151" fontSize="12" textAnchor="middle" transform="rotate(-90 20 150)">
                                                WCSS
                                            </text>

                                            {/* X-axis label */}
                                            <text x="320" y="285" fill="#374151" fontSize="12" textAnchor="middle">
                                                Number of Clusters (k)
                                            </text>

                                            {(() => {
                                                const maxWCSS = Math.max(...results.elbowData.map(d => d.wcss));
                                                const minWCSS = Math.min(...results.elbowData.map(d => d.wcss));
                                                const wcssRange = maxWCSS - minWCSS;

                                                const xScale = (k) => 60 + ((k - 1) / 9) * 520;
                                                const yScale = (wcss) => 250 - ((wcss - minWCSS) / wcssRange) * 200;

                                                const points = results.elbowData.map(d => ({
                                                    x: xScale(d.k),
                                                    y: yScale(d.wcss),
                                                    k: d.k,
                                                    wcss: d.wcss
                                                }));

                                                const pathData = points.map((p, i) =>
                                                    `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`
                                                ).join(' ');

                                                return (
                                                    <>
                                                        {/* Line */}
                                                        <path
                                                            d={pathData}
                                                            fill="none"
                                                            stroke="#10b981"
                                                            strokeWidth="3"
                                                            strokeLinecap="round"
                                                            strokeLinejoin="round"
                                                        />

                                                        {/* Points */}
                                                        {points.map((p, i) => (
                                                            <g key={i}>
                                                                <circle
                                                                    cx={p.x}
                                                                    cy={p.y}
                                                                    r="5"
                                                                    fill={p.k === k ? '#059669' : '#10b981'}
                                                                    stroke="white"
                                                                    strokeWidth="2"
                                                                />
                                                                {/* X-axis tick labels */}
                                                                <text
                                                                    x={p.x}
                                                                    y="270"
                                                                    fill="#374151"
                                                                    fontSize="11"
                                                                    textAnchor="middle"
                                                                >
                                                                    {p.k}
                                                                </text>
                                                                {/* Highlight current k */}
                                                                {p.k === k && (
                                                                    <>
                                                                        <circle
                                                                            cx={p.x}
                                                                            cy={p.y}
                                                                            r="8"
                                                                            fill="none"
                                                                            stroke="#059669"
                                                                            strokeWidth="2"
                                                                        />
                                                                        <text
                                                                            x={p.x}
                                                                            y={p.y - 15}
                                                                            fill="#059669"
                                                                            fontSize="12"
                                                                            fontWeight="bold"
                                                                            textAnchor="middle"
                                                                        >
                                                                            Current
                                                                        </text>
                                                                    </>
                                                                )}
                                                            </g>
                                                        ))}

                                                        {/* Y-axis tick labels */}
                                                        {[0, 1, 2, 3, 4].map(i => {
                                                            const value = maxWCSS - (i * wcssRange / 4);
                                                            return (
                                                                <text
                                                                    key={`ylabel-${i}`}
                                                                    x="50"
                                                                    y={55 + i * 50}
                                                                    fill="#374151"
                                                                    fontSize="11"
                                                                    textAnchor="end"
                                                                >
                                                                    {value.toFixed(0)}
                                                                </text>
                                                            );
                                                        })}
                                                    </>
                                                );
                                            })()}
                                        </svg>
                                    </div>

                                    <div className="mt-4 p-4 bg-green-50 rounded-lg">
                                        <p className="text-sm text-gray-700">
                                            <strong>Tip:</strong> Look for the "elbow" point where the curve bends and the rate of decrease in WCSS sharply changes.
                                            This suggests the optimal number of clusters. The current k={k} is highlighted on the plot.
                                        </p>
                                    </div>
                                </div>

                                <div className="bg-white rounded-lg shadow-lg p-8">
                                    <h2 className="text-2xl font-bold text-green-600 mb-4">Customer Assignments</h2>
                                    <div className="overflow-x-auto">
                                        <table className="min-w-full text-sm">
                                            <thead>
                                                <tr className="bg-green-50">
                                                    <th className="px-3 py-2 text-left text-xs font-semibold text-green-700">Customer ID</th>
                                                    {results.features.map(feature => (
                                                        <th key={feature} className="px-3 py-2 text-left text-xs font-semibold text-green-700">{feature}</th>
                                                    ))}
                                                    <th className="px-3 py-2 text-left text-xs font-semibold text-green-700">Cluster</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {results.dataWithClusters.slice(0, 20).map((row, idx) => (
                                                    <tr key={idx} className="border-b border-gray-200">
                                                        <td className="px-3 py-2">{row.CustomerID}</td>
                                                        {results.features.map(feature => (
                                                            <td key={feature} className="px-3 py-2">{row[feature]}</td>
                                                        ))}
                                                        <td className="px-3 py-2">
                                                            <span className="bg-green-100 text-green-700 px-2 py-1 rounded text-xs font-semibold">
                                                                {row.Cluster}
                                                            </span>
                                                        </td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                        {results.dataWithClusters.length > 20 && (
                                            <p className="text-sm text-gray-500 mt-2">
                                                Showing first 20 of {results.dataWithClusters.length} customers
                                            </p>
                                        )}
                                    </div>
                                </div>

                                {/* Interpretation Guide */}
                                <div className="bg-white rounded-lg shadow-md p-6 mb-8">
                                    <h2 className="text-2xl font-bold mb-4 text-gray-800">How to Interpret Your Results</h2>

                                    <div className="space-y-4">
                                        <div className="border-l-4 border-green-500 pl-4">
                                            <h3 className="font-bold text-green-900 mb-2">Cluster Summaries</h3>
                                            <p className="text-sm text-gray-700 mb-2">
                                                Each cluster represents a distinct customer segment with similar characteristics.
                                            </p>
                                            <ul className="text-sm text-gray-600 space-y-1 ml-4">
                                                <li>• Look at <strong>mean values</strong> for each feature to understand cluster profile</li>
                                                <li>• <strong>Cluster size</strong> shows how many customers fall into each segment</li>
                                                <li>• Compare clusters to identify what makes each segment unique</li>
                                            </ul>
                                        </div>

                                        <div className="border-l-4 border-blue-500 pl-4">
                                            <h3 className="font-bold text-blue-900 mb-2">Within-Cluster Sum of Squares (WCSS)</h3>
                                            <p className="text-sm text-gray-700 mb-2">
                                                Measures how tightly grouped the data points are within each cluster (calculated on standardized features).
                                            </p>
                                            <ul className="text-sm text-gray-600 space-y-1 ml-4">
                                                <li>• <strong>Lower WCSS</strong> = Tighter, more cohesive clusters (better separation)</li>
                                                <li>• <strong>Higher WCSS</strong> = More spread out, less distinct clusters</li>
                                                <li>• Compare across different k values to find optimal number of clusters</li>
                                                <li>• Good clustering typically shows WCSS &lt; 10 at the optimal k</li>
                                                <li>• WCSS of 2-5 indicates very distinct, well-separated clusters</li>
                                            </ul>
                                        </div>

                                        <div className="border-l-4 border-purple-500 pl-4">
                                            <h3 className="font-bold text-purple-900 mb-2">Elbow Plot Analysis</h3>
                                            <p className="text-sm text-gray-700 mb-2">
                                                Use the elbow plot data to determine the optimal number of clusters.
                                            </p>
                                            <ul className="text-sm text-gray-600 space-y-1 ml-4">
                                                <li>• Look for the "elbow" - where WCSS decreases sharply then levels off</li>
                                                <li>• The k value at the elbow is often the optimal number of clusters</li>
                                                <li>• Adding clusters beyond the elbow gives diminishing returns</li>
                                                <li>• Also consider business constraints (can you target 3 vs 5 segments?)</li>
                                            </ul>
                                        </div>

                                        <div className="bg-yellow-50 border-l-4 border-yellow-500 p-4">
                                            <h3 className="font-bold text-yellow-900 mb-2">Quick Action Guide</h3>
                                            <ol className="text-sm text-gray-700 space-y-2 list-decimal ml-4">
                                                <li>Review each cluster's mean values to create a profile/persona</li>
                                                <li>Give each cluster a descriptive name (e.g., "High-Value Frequent Buyers")</li>
                                                <li>Check the elbow plot to validate if k is optimal</li>
                                                <li>Use cluster insights to tailor marketing, pricing, or product strategies</li>
                                                <li>Monitor cluster assignments over time to track customer segment changes</li>
                                            </ol>
                                        </div>

                                        <div className="bg-green-50 border-l-4 border-green-500 p-4">
                                            <h3 className="font-bold text-green-900 mb-2">Common Cluster Interpretations</h3>
                                            <ul className="text-sm text-gray-700 space-y-2">
                                                <li>• <strong>High Age + High Income + Low Frequency</strong>: Occasional luxury buyers</li>
                                                <li>• <strong>Young + Low Income + High Frequency</strong>: Budget-conscious regulars</li>
                                                <li>• <strong>Middle Age + High Income + High Order Value</strong>: Premium customers</li>
                                                <li>• <strong>Low across all metrics</strong>: At-risk or dormant customers</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ClusterAnalysisCalculator />);
    </script>
</body>
</html>
